package main

import (
	"fmt"
	"strings"
	"text/template"
)

type analysisData struct {
	Command           string
	PackageName       string
	PackageFQN        string
	TypeName          string
	WrapperTypeName   string
	TypesAndValues    map[string][]string
	TargetPackageName string
}

var typeWrapperTemplate = template.Must(template.New("").Parse(`// Code generated by go wasm-bindings {{.Command}}; DO NOT EDIT.

package {{.TargetPackageName}}

import "{{.PackageFQN}}"
import "syscall/js"

type {{.WrapperTypeName}} struct {
	wrapped *{{.PackageName}}.{{.TypeName}}
}

func wrap(t {{.PackageName}}.{{.TypeName}}) {{.WrapperTypeName}} {
	return {{.WrapperTypeName}}{
		wrapped: &t,
	}
}
`))

type functionData struct {
	FunctionName    string
	WrapperTypeName string
	Types           []string
}

func functionWrapperTempl(d functionData) string {
	b := strings.Builder{}
	b.WriteString("func (w *" + d.WrapperTypeName + ") Js" + d.FunctionName + "(this js.Value, args []js.Value) any {\n")
	for i, typ := range d.Types {
		switch typ {
		case "int64":
			b.WriteString(fmt.Sprintf("param%d := int64(args[%d].Float())\n", i, i))
		case "int":
			b.WriteString(fmt.Sprintf("param%d := args[%d].Int()\n", i, i))
		case "string":
			b.WriteString(fmt.Sprintf("param%d := args[%d].String()\n", i, i))
		default:
			b.WriteString(fmt.Sprintf("param%d := args[%d].String()\n", i, i))
		}
	}
	params := ""
	for i, _ := range d.Types {
		if i > 0 {
			params = params + ", "
		}
		params = params + fmt.Sprintf("param%d", i)
	}
	b.WriteString("w.wrapped." + d.FunctionName + "(" + params + ")\n")
	b.WriteString("return js.Undefined()\n")
	b.WriteString("}\n \n")
	return b.String()
}
